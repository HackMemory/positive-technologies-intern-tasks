# Задача


Исследовать публичные CVE:

CVE-2022-35919

CVE-2019-9194

CVE-2018-20434

По каждой из них включить в отчёт:

a. Ссылку на коммит, исправляющий уязвимость

b. Перечень значимых строк кода, относящихся к уязвимости

c. Регулярное выражение, позволяющее максимально точно детектировать атаку на данную уязвимость в потоке трафика

d. Перечень всех функций публичного API уязвимого приложения/компонента, из которых возможно достижение строк из п.b

# CVE-2022-35919

Уязвимость в приложении объектного хранилища MinIO выражается в том, что в процессе обновления приложения возможно указать ссылку на обновление. Однако из-за данной уязвимости становится возможным чтение локальных файлов на устройстве.

1. [https://github.com/minio/minio/commit/bc72e4226e669d98c8e0f3eccc9297be9251c692](https://github.com/minio/minio/commit/bc72e4226e669d98c8e0f3eccc9297be9251c692)
2.
```go
if u.Scheme == "https" || u.Scheme == "http" {
…………
} else {
    reader, err = os.Open(u.Path)
    if err != nil {
        return content, AdminError {
            Code: AdminUpdateURLNotReachable,
            Message: err.Error(),
            StatusCode: http.StatusServiceUnavailable,
        }
    }
}
contentBytes, err := ioutil.ReadAll(reader)
```

В случае, если в параметр downloadReleaseURL передается не ссылка, приложение производит чтение локального файла, что открывает возможность для чтения файла, который разрешает операционная система.

c. Так как мы выяснили по коду, чтобы прочитать локально файл, нужно, чтобы в метод передавалась не ссылка. Тем самым можно написать простое регулярное выражение, которое будет при запросе на обновление, проверять есть ли ссылка в параметре updateURL:

```(.\*?)(/\*minio/\*admin/\*v3/\*update\?updateURL=)(http|https)?:\/\/(\S+)```

Пример тестирования можно посмотреть в файле [task1_1.py](task1_1.py)

# CVE-2019-9194

Уязвимость заключается в том, что не происходит экранирования строк. Эксплуатация уязвимости получается путем того, что мы называем файл в виде команд для терминала.
 Как в примере, указывается название файла:

_SecSignal.jpg;echo 3c3f7068702073797374656d28245f4745545b2263225d293b203f3e0a | xxd -r -p \> SecSignal.php;echo SecSignal.jpg_

Для того, чтобы эти команды выполнились, нам нужно как-то сделать так, чтобы приложение взаимодействовала с утилитами, которые встроены в ОС.
 И тут можем заметить, что при повороте картинки, у нас вызывается такая консольная утилита, как exiftran или jpegtran. И из-за того, что строка, которая получена по хэшу (впоследствии по хэшу получает название файла), мы можем без проблем выполнить консольные команды.

a. [https://github.com/Studio-42/elFinder/compare/2.1.47...2.1.48](https://github.com/Studio-42/elFinder/compare/2.1.47...2.1.48)


b. Файл php/elFinderVolumeDriver.class.php

```php
$quotedPath = escapeshellarg($path);
$cmds = array();
if ($this-\>procExec(ELFINDER\_EXIFTRAN\_PATH . ' -h') === 0) {
$cmds[] = ELFINDER\_EXIFTRAN\_PATH . ' -i ' . $exiftran[$count] . ' ' . $path;
```

c. Для того, чтобы с помощью регулярного выражения выявить атаку на эту уязвимость, достаточно проверять, является ли это названием файла и ничего более:

```^\s\*[\w\d\s@#$%^&\*()\_+-=,.;\'{}[\]]+\.(jpg|jpeg|png|gif)\s\*$```

Пример тестирования можно посмотреть в файле [task1_2.py](task1_2.py)

# CVE-2018-20434

Уязвимость в этом приложении появляется по той же причине, как и в предыдущей, нет экранирования строк. Только тут мы можем просто передать вредоносную строку в теле запроса и при вызове обращению к определенному эндпоинту, мы сможем стригерить вызов этой вредоносной строки.
a. [https://github.com/librenms/librenms/pull/9537/commits/271191c82dbefe58bdc05f302c4532e798f10624](https://github.com/librenms/librenms/pull/9537/commits/271191c82dbefe58bdc05f302c4532e798f10624)

b. **snmp.inc.php** – _проблема с экранированием_
$cmd .= " -c '".$device['community']."'"; // нет экранирования строки

**capture.inc.php** – _popen_ даст выполнить вредоносную строку
```php
if (($fp = popen($cmd, "r"))) {
    while (!feof($fp)) {
        $line = stream\_get\_line($fp, 1024, PHP\_EOL);
        echo preg\_replace('/\033\[[\d;]+m/', '', $line) . PHP\_EOL;
        ob\_flush();
        flush();
    }
    
    fclose($fp);
}
```

c. Поизучав немного код, стало понятно, что он вызывает такую утилиту, как _snmpbulkwalk,_ и с помощью ключа -c передает то самое значение _community_. И из того, что я понял, он может принимать строки без каких-либо спецсимволов, тем самым мы можем написать регулярное выражение, которое будет валидировать строку, где будут только символы, цифры, пробелы…
 Регулярное выражение: ```^[\w\s\-]+$```

Пример тестирования можно посмотреть в файле [task1_3.py](task1_3.py)
